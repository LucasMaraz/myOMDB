{"ast":null,"code":"\"use strict\";\n\nvar _s = $RefreshSig$();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useIntersection = useIntersection;\n\nvar _react = require(\"react\");\n\nvar _requestIdleCallback = require(\"./request-idle-callback\");\n\nconst hasIntersectionObserver = typeof IntersectionObserver !== 'undefined';\n\nfunction useIntersection({\n  rootMargin,\n  disabled\n}) {\n  _s();\n\n  const isDisabled = disabled || !hasIntersectionObserver;\n  const unobserve = (0, _react).useRef();\n  const [visible, setVisible] = (0, _react).useState(false);\n  const setRef = (0, _react).useCallback(el => {\n    if (unobserve.current) {\n      unobserve.current();\n      unobserve.current = undefined;\n    }\n\n    if (isDisabled || visible) return;\n\n    if (el && el.tagName) {\n      unobserve.current = observe(el, isVisible => isVisible && setVisible(isVisible), {\n        rootMargin\n      });\n    }\n  }, [isDisabled, rootMargin, visible]);\n  (0, _react).useEffect(() => {\n    if (!hasIntersectionObserver) {\n      if (!visible) {\n        const idleCallback = (0, _requestIdleCallback).requestIdleCallback(() => setVisible(true));\n        return () => (0, _requestIdleCallback).cancelIdleCallback(idleCallback);\n      }\n    }\n  }, [visible]);\n  return [setRef, visible];\n}\n\n_s(useIntersection, \"Z6jj7qx+KE6gD9CpC9WlQTha45o=\");\n\nfunction observe(element, callback, options) {\n  const {\n    id,\n    observer,\n    elements\n  } = createObserver(options);\n  elements.set(element, callback);\n  observer.observe(element);\n  return function unobserve() {\n    elements.delete(element);\n    observer.unobserve(element); // Destroy observer when there's nothing left to watch:\n\n    if (elements.size === 0) {\n      observer.disconnect();\n      observers.delete(id);\n    }\n  };\n}\n\nconst observers = new Map();\n\nfunction createObserver(options) {\n  const id = options.rootMargin || '';\n  let instance = observers.get(id);\n\n  if (instance) {\n    return instance;\n  }\n\n  const elements = new Map();\n  const observer = new IntersectionObserver(entries => {\n    entries.forEach(entry => {\n      const callback = elements.get(entry.target);\n      const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n\n      if (callback && isVisible) {\n        callback(isVisible);\n      }\n    });\n  }, options);\n  observers.set(id, instance = {\n    id,\n    observer,\n    elements\n  });\n  return instance;\n}","map":{"version":3,"sources":["../../client/use-intersection.tsx"],"names":[],"mappings":";;;;;;;QAiBgB,e,GAAA,e;;AAjByC,IAAA,MAAO,GAAA,OAAA,CAAA,OAAA,CAAP;;AAIlD,IAAA,oBAAyB,GAAA,OAAA,CAAA,yBAAA,CAAzB;;AAWP,MAAM,uBAAuB,GAAG,OAAO,oBAAP,KAAgC,WAAhE;;SAEgB,e,CAAmC;AACjD,EAAA,UADiD;AAEjD,EAAA;AAFiD,C,EAGS;AAAA;;AAC1D,QAAM,UAAU,GAAY,QAAQ,IAAA,CAAK,uBAAzC;AAEA,QAAM,SAAS,GAAA,CAAA,GAvBwC,MAuBxC,EAvB+C,MAuB/C,EAAf;AACA,QAAK,CAAE,OAAF,EAAW,UAAX,IAAqB,CAAA,GAxB6B,MAwB7B,EAxBoC,QAwBpC,CAAa,KAAb,CAA1B;AAEA,QAAM,MAAM,GAAA,CAAA,GA1B2C,MA0B3C,EA1BkD,WA0BlD,CACT,EA3B2D,IA2B1C;AAChB,QAAI,SAAS,CAAC,OAAd,EAAuB;AACrB,MAAA,SAAS,CAAC,OAAV;AACA,MAAA,SAAS,CAAC,OAAV,GAAoB,SAApB;AACD;;AAED,QAAI,UAAU,IAAI,OAAlB,EAA2B;;AAE3B,QAAI,EAAE,IAAI,EAAE,CAAC,OAAb,EAAsB;AACpB,MAAA,SAAS,CAAC,OAAV,GAAoB,OAAO,CACzB,EADyB,EAExB,SADC,IACa,SAAS,IAAI,UAAU,CAAC,SAAD,CAFb,EAGzB;AAAE,QAAA;AAAF,OAHyB,CAA3B;AAKD;AACF,GAhBS,EAiBV,CAAC,UAAD,EAAa,UAAb,EAAyB,OAAzB,CAjBU,CAAZ;MA1BuD,M,EAAO,S,CAAA,MA8C9C;AACd,QAAE,CAAG,uBAAL,EAA8B;AAC5B,UAAE,CAAG,OAAL,EAAc;AACZ,cAAM,YAAY,GAAA,CAAA,GA7CnB,oBA6CmB,EA7CM,mBA6CN,CA7CM,MA6CuB,UAAU,CAAC,IAAD,CAAvC,CAAlB;AACA,eAAM,MAAA,CAAA,GA9CP,oBA8CO,EA9CkB,kBA8ClB,CAA0B,YAA1B,CAAN;AACD;AACF;AACF,G,EAAE,CAAC,OAAD,C;AAEH,SAAO,CAAC,MAAD,EAAS,OAAT,CAAP;AACD;;GAvCe,e;;SAyCP,O,CACP,O,EACA,Q,EACA,O,EACY;AACZ,QAAM;AAAE,IAAA,EAAF;AAAM,IAAA,QAAN;AAAgB,IAAA;AAAhB,MAA6B,cAAc,CAAC,OAAD,CAAjD;AACA,EAAA,QAAQ,CAAC,GAAT,CAAa,OAAb,EAAsB,QAAtB;AAEA,EAAA,QAAQ,CAAC,OAAT,CAAiB,OAAjB;AACA,SAAO,SAAS,SAAT,GAA2B;AAChC,IAAA,QAAQ,CAAC,MAAT,CAAgB,OAAhB;AACA,IAAA,QAAQ,CAAC,SAAT,CAAmB,OAAnB,EAFgC,CAIhC;;AACA,QAAI,QAAQ,CAAC,IAAT,KAAkB,CAAtB,EAAyB;AACvB,MAAA,QAAQ,CAAC,UAAT;AACA,MAAA,SAAS,CAAC,MAAV,CAAiB,EAAjB;AACD;AACF,GATD;AAUD;;AAED,MAAM,SAAS,GAAG,IAAI,GAAJ,EAAlB;;SACS,c,CAAe,O,EAAgD;AACtE,QAAM,EAAE,GAAG,OAAO,CAAC,UAAR,IAAsB,EAAjC;AACA,MAAI,QAAQ,GAAG,SAAS,CAAC,GAAV,CAAc,EAAd,CAAf;;AACA,MAAI,QAAJ,EAAc;AACZ,WAAO,QAAP;AACD;;AAED,QAAM,QAAQ,GAAG,IAAI,GAAJ,EAAjB;AACA,QAAM,QAAQ,GAAG,IAAI,oBAAJ,CAA0B,OAAF,IAAc;AACrD,IAAA,OAAO,CAAC,OAAR,CAAiB,KAAF,IAAY;AACzB,YAAM,QAAQ,GAAG,QAAQ,CAAC,GAAT,CAAa,KAAK,CAAC,MAAnB,CAAjB;AACA,YAAM,SAAS,GAAG,KAAK,CAAC,cAAN,IAAwB,KAAK,CAAC,iBAAN,GAA0B,CAApE;;AACA,UAAI,QAAQ,IAAI,SAAhB,EAA2B;AACzB,QAAA,QAAQ,CAAC,SAAD,CAAR;AACD;AACF,KAND;AAOD,GARgB,EAQd,OARc,CAAjB;AAUA,EAAA,SAAS,CAAC,GAAV,CACE,EADF,EAEG,QAAQ,GAAG;AACV,IAAA,EADU;AAEV,IAAA,QAFU;AAGV,IAAA;AAHU,GAFd;AAQA,SAAO,QAAP;AACD","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.useIntersection = useIntersection;\nvar _react = require(\"react\");\nvar _requestIdleCallback = require(\"./request-idle-callback\");\nconst hasIntersectionObserver = typeof IntersectionObserver !== 'undefined';\nfunction useIntersection({ rootMargin , disabled  }) {\n    const isDisabled = disabled || !hasIntersectionObserver;\n    const unobserve = (0, _react).useRef();\n    const [visible, setVisible] = (0, _react).useState(false);\n    const setRef = (0, _react).useCallback((el)=>{\n        if (unobserve.current) {\n            unobserve.current();\n            unobserve.current = undefined;\n        }\n        if (isDisabled || visible) return;\n        if (el && el.tagName) {\n            unobserve.current = observe(el, (isVisible)=>isVisible && setVisible(isVisible)\n            , {\n                rootMargin\n            });\n        }\n    }, [\n        isDisabled,\n        rootMargin,\n        visible\n    ]);\n    (0, _react).useEffect(()=>{\n        if (!hasIntersectionObserver) {\n            if (!visible) {\n                const idleCallback = (0, _requestIdleCallback).requestIdleCallback(()=>setVisible(true)\n                );\n                return ()=>(0, _requestIdleCallback).cancelIdleCallback(idleCallback)\n                ;\n            }\n        }\n    }, [\n        visible\n    ]);\n    return [\n        setRef,\n        visible\n    ];\n}\nfunction observe(element, callback, options) {\n    const { id , observer , elements  } = createObserver(options);\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements.delete(element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers.delete(id);\n        }\n    };\n}\nconst observers = new Map();\nfunction createObserver(options) {\n    const id = options.rootMargin || '';\n    let instance = observers.get(id);\n    if (instance) {\n        return instance;\n    }\n    const elements = new Map();\n    const observer = new IntersectionObserver((entries)=>{\n        entries.forEach((entry)=>{\n            const callback = elements.get(entry.target);\n            const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    observers.set(id, instance = {\n        id,\n        observer,\n        elements\n    });\n    return instance;\n}\n\n//# sourceMappingURL=use-intersection.js.map"]},"metadata":{},"sourceType":"module"}